================================================================================
FILE: collect_text_and_tree.py  (size: 9486 bytes)
================================================================================
#!/usr/bin/env python3
"""
Collect project sources:
- For text files: write full contents (preserved exactly).
- For non-text files: write only the file name (marked as UNSUPPORTED/BINARY).
- Finally, append an ASCII tree of the entire project.

Defaults: excludes heavy build/dependency folders (.next, node_modules) and lockfiles (package-lock.json);
includes hidden files; deterministic order.
You can pass --exclude to skip additional directories/files by name, and --followlinks to follow symlinks.
"""

from __future__ import annotations
import argparse
import os
from pathlib import Path
import sys
import tokenize
import mimetypes

HEADER_LINE = "=" * 80

# Common text-like extensions (still fallback to detection)
TEXT_EXTS = {
    # Code
    ".java", ".kt", ".kts",
    ".js", ".ts", ".jsx", ".tsx",
    ".css", ".scss", ".sass", ".less",
    ".html", ".htm", ".vue", ".svelte",
    ".c", ".h", ".cpp", ".hpp", ".cc", ".m", ".mm",
    ".go", ".rs", ".php", ".rb", ".swift", ".scala",
    ".cs", ".sql", ".sh", ".bat", ".ps1",".py",
    # Config / data / docs
    ".json", ".yaml", ".yml", ".xml", ".ini", ".cfg", ".conf", ".properties",
    ".toml", ".gradle", ".md", ".txt", ".env", ".csv", ".tsv",
    ".gitignore", ".gitattributes", ".editorconfig", ".prettierrc", ".eslintrc",
}

# MIME types we treat as text even if extension is unknown
TEXT_MIME_PREFIXES = ("text/",)
TEXT_MIME_EXTRAS = {
    "application/json", "application/xml", "application/javascript",
    "application/x-sh", "application/x-shellscript",
}

# Default names to skip while walking/printing the tree (directories or files)
DEFAULT_EXCLUDES = {".next", "node_modules", ".idea", ".venv", "package-lock.json"}

# ---------- Helpers ----------

def _has_bom(head: bytes) -> str | None:
    if head.startswith(b"\xef\xbb\xbf"):
        return "utf-8-sig"
    if head.startswith(b"\xff\xfe\x00\x00"):
        return "utf-32-le"
    if head.startswith(b"\x00\x00\xfe\xff"):
        return "utf-32-be"
    if head.startswith(b"\xff\xfe"):
        return "utf-16-le"
    if head.startswith(b"\xfe\xff"):
        return "utf-16-be"
    return None

def _looks_binary(head: bytes) -> bool:
    if b"\x00" in head:
        return True
    # Consider control chars (excluding \t, \n, \r, \f) as "weird"
    weird = sum(1 for b in head if (b < 32 and b not in (9, 10, 13, 12)))
    # If > 30% are weird control bytes, likely binary
    return (len(head) > 0) and (weird / len(head) > 0.30)

def is_text_file(path: Path, sample_bytes: int = 4096) -> bool:
    # 1) Obvious by extension
    if path.suffix.lower() in TEXT_EXTS:
        return True
    # 2) BOM presence indicates text
    try:
        with path.open("rb") as f:
            head = f.read(sample_bytes)
    except Exception:
        return False
    if _has_bom(head):
        return True
    # 3) MIME hint
    mt, _ = mimetypes.guess_type(path.as_posix())
    if mt and (mt.startswith(TEXT_MIME_PREFIXES) or mt in TEXT_MIME_EXTRAS):
        return True
    # 4) Heuristic on bytes
    return not _looks_binary(head)

def read_text_preserve(path: Path) -> str:
    """Read text preserving original characters as closely as possible."""
    # Respect PEP 263 for Python files
    if path.suffix.lower() == ".py":
        with tokenize.open(path) as f:
            return f.read()
    # BOM-aware for common Unicode encodings
    with path.open("rb") as fb:
        head = fb.read(4)
    enc = _has_bom(head)
    if enc:
        return path.read_text(encoding=enc)
    # Try UTF-8, then Latin-1 (lossless mapping of bytes 0–255)
    try:
        return path.read_text(encoding="utf-8")
    except UnicodeDecodeError:
        return path.read_text(encoding="latin-1")

def write_header(out, rel_path: Path, size_bytes: int | None, marker: str | None = None):
    out.write(f"{HEADER_LINE}\n")
    out.write(f"FILE: {rel_path.as_posix()}")
    if size_bytes is not None:
        out.write(f"  (size: {size_bytes} bytes)")
    if marker:
        out.write(f"  [{marker}]")
    out.write("\n")
    out.write(f"{HEADER_LINE}\n")

def iter_all_files(root: Path, followlinks: bool, exclude_names: set[str]) -> list[Path]:
    """
    Walk the tree and return all file paths, skipping any directory whose *name*
    is in exclude_names, and skipping any file whose *name* is in exclude_names.
    """
    files: list[Path] = []
    for dirpath, dirnames, filenames in os.walk(root, followlinks=followlinks):
        # prune directories by name
        if exclude_names:
            dirnames[:] = [d for d in dirnames if d not in exclude_names]
        # skip files by name (e.g., 'package-lock.json')
        for fn in filenames:
            if fn in exclude_names:
                continue
            files.append(Path(dirpath) / fn)
    files.sort(key=lambda p: p.as_posix().lower())
    return files

def tree_lines(root: Path, exclude_names: set[str], followlinks: bool) -> list[str]:
    """Produce an ASCII tree (dirs then files, sorted), excluding entries by name."""
    lines: list[str] = [f"{root.name}/"]
    def walk(d: Path, prefix: str):
        try:
            entries = sorted(
                [e for e in d.iterdir() if e.name not in exclude_names],
                key=lambda p: (not p.is_dir(), p.name.lower())
            )
        except PermissionError:
            return
        for i, e in enumerate(entries):
            last = (i == len(entries) - 1)
            conn = "└── " if last else "├── "
            if e.is_dir():
                lines.append(f"{prefix}{conn}{e.name}/")
                walk(e, prefix + ("    " if last else "│   "))
            else:
                lines.append(f"{prefix}{conn}{e.name}")
    walk(root, "")
    return lines

# ---------- Main logic ----------

def collect(root: Path, out_path: Path, followlinks: bool, exclude_names: set[str]) -> int:
    root = root.resolve()
    out_path = out_path.resolve()

    if not root.exists() or not root.is_dir():
        print(f"Error: root '{root}' is not a directory.", file=sys.stderr)
        return 2

    files = iter_all_files(root, followlinks, exclude_names)
    if not files:
        print("No files found.", file=sys.stderr)
        return 1

    out_path.parent.mkdir(parents=True, exist_ok=True)

    text_count = 0
    bin_count = 0

    with out_path.open("w", encoding="utf-8", newline="\n") as out:
        for f in files:
            # Don't include the output file itself
            try:
                if f.resolve() == out_path:
                    continue
            except Exception:
                pass

            rel = f.relative_to(root)
            try:
                size_bytes = f.stat().st_size
            except Exception:
                size_bytes = None

            try:
                if is_text_file(f):
                    content = read_text_preserve(f)
                    write_header(out, rel, size_bytes)
                    out.write(content)
                    if not content.endswith("\n"):
                        out.write("\n")
                    out.write("\n")
                    text_count += 1
                else:
                    write_header(out, rel, size_bytes, marker="UNSUPPORTED/NON-TEXT")
                    out.write("(contents omitted)\n\n")
                    bin_count += 1
            except Exception as e:
                write_header(out, rel, size_bytes, marker="READ_ERROR")
                out.write(f"[ERROR] {e}\n\n")
                bin_count += 1

        # ---- Append project tree ----
        out.write(f"{HEADER_LINE}\nPROJECT TREE\n{HEADER_LINE}\n")
        for line in tree_lines(root, exclude_names, followlinks):
            out.write(line + "\n")

        # ---- Summary ----
        out.write("\n")
        out.write(f"{HEADER_LINE}\nSUMMARY\n{HEADER_LINE}\n")
        out.write(f"Text files written : {text_count}\n")
        out.write(f"Non-text/omitted   : {bin_count}\n")
        out.write(f"Total files seen   : {len(files)}\n")

    print(f"Done. Text={text_count}  Non-text={bin_count}  Wrote -> '{out_path}'.")
    return 0

def parse_excludes(argv_excludes: list[str]) -> set[str]:
    """
    Accept bare names (directories or files) to exclude while walking and when printing the tree.
    Always include defaults (.next, node_modules, .idea, .venv, package-lock.json), while allowing users to add more.
    """
    return DEFAULT_EXCLUDES.union(set(argv_excludes or []))

def main():
    ap = argparse.ArgumentParser(
        description="Write all text files, list non-text files, then append project tree."
    )
    ap.add_argument("root", type=Path, help="Root directory to scan")
    ap.add_argument("output", type=Path, help="Output .txt file")
    ap.add_argument(
        "--exclude",
        nargs="*",
        default=[],
        help="Extra directory/file names to exclude in addition to defaults (space-separated)"
    )
    ap.add_argument("--followlinks", action="store_true", help="Follow symlinked directories")
    args = ap.parse_args()

    exclude_names = parse_excludes(args.exclude)
    rc = collect(args.root, args.output, followlinks=args.followlinks, exclude_names=exclude_names)
    sys.exit(rc)

if __name__ == "__main__":
    main()

================================================================================
FILE: dashboard/page.tsx  (size: 1810 bytes)
================================================================================
'use client';
import { useEffect, useMemo, useState } from 'react';
import { useRouter } from 'next/navigation';
import { api } from '@features/auth/api';
import { useAuthGuard } from '@features/auth/hooks';
import Link from 'next/link';

type Health = { ok: boolean; service: string };

export default function DashboardPage() {
    useAuthGuard();
    const router = useRouter();
    const [health, setHealth] = useState<Health | null>(null);

    const base = useMemo(() => process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:4000', []);

    useEffect(() => {
        const t = localStorage.getItem('accessToken');
        if (!t) { router.replace('/login'); return; }
        api.get(`${base}/health`).then(r => setHealth(r.data)).catch(() => setHealth(null));
    }, [router, base]);

    const logout = () => { 
        localStorage.removeItem('accessToken'); 
        localStorage.removeItem('refreshToken'); 
        router.replace('/login'); 
    };

    return (
        <main className="p-6 max-w-3xl mx-auto">
            <div className="flex items-center justify-between">
                <h1 className="text-2xl font-semibold">Doctor Dashboard</h1>
                <button className="text-sm underline" onClick={logout}>Logout</button>
            </div>
            <div className="mt-4 bg-white rounded p-4 shadow">
                <p className="text-sm">Backend health: {health ? <span className="text-green-700">OK ({health.service})</span> : <span className="text-red-700">Unavailable</span>}</p>
            </div>
            <div className="mt-4 bg-white rounded p-4 shadow">
                <h2 className="font-medium mb-2">Patients</h2>
                <Link className="text-blue-700 underline" href="/patients">Invite a patient</Link>
            </div>
        </main>
    );
}

================================================================================
FILE: globals.css  (size: 224 bytes)
================================================================================
:root{
    --bg:#0b1220; --card:#0f172a; --muted:#93a4c4; --text:#e6edff;
    --ring:rgba(99,102,241,0.35); --primary:#6366f1; --primary-600:#5457ee;
    --ok:#22c55e; --err:#ef4444; --border:#1f2a44; --warn:#f59e0b;
}

================================================================================
FILE: layout.tsx  (size: 255 bytes)
================================================================================
export const metadata = {
  title: 'Next.js',
  description: 'Generated by Next.js',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}

================================================================================
FILE: login/page.tsx  (size: 1949 bytes)
================================================================================
'use client';
import { useState } from 'react';
import { login, setAuth } from '@features/auth/api';
import { useRouter } from 'next/navigation';

export default function LoginPage() {
    const [email, setEmail] = useState('doctor@example.com');
    const [password, setPassword] = useState('');
    const [loading, setLoading] = useState(false);
    const [msg, setMsg] = useState<string | null>(null);
    const router = useRouter();

    const onLogin = async (e: React.FormEvent) => {
        e.preventDefault();
        setLoading(true); setMsg(null);
        try {
            const { data } = await login(email, password);
            localStorage.setItem('accessToken', data.accessToken);
            localStorage.setItem('refreshToken', data.refreshToken);
            setAuth(data.accessToken);
            router.replace('/dashboard');
        } catch (e:any) {
            setMsg(e?.response?.data?.error || 'Login failed');
        } finally { setLoading(false); }
    };

    return (
        <main className="min-h-screen flex items-center justify-center p-6">
            <form onSubmit={onLogin} className="w-full max-w-md bg-white p-6 rounded-lg shadow">
                <h1 className="text-xl font-semibold mb-4">Doctor Login</h1>
                {msg && <div className="bg-red-100 text-red-700 p-2 rounded mb-3">{msg}</div>}
                <label className="block text-sm mb-1">Email</label>
                <input className="w-full border rounded px-3 py-2 mb-3" value={email} onChange={e=>setEmail(e.target.value)}/>
                <label className="block text-sm mb-1">Password</label>
                <input type="password" className="w-full border rounded px-3 py-2 mb-4" value={password} onChange={e=>setPassword(e.target.value)}/>
                <button disabled={loading} className="w-full bg-black text-white py-2 rounded">{loading? 'Signing in...' : 'Sign In'}</button>
            </form>
        </main>
    );
}

================================================================================
FILE: page.tsx  (size: 333 bytes)
================================================================================
'use client';
import { useEffect } from 'react';
import { useRouter } from 'next/navigation';

export default function Home() {
    const router = useRouter();
    useEffect(() => {
        const t = localStorage.getItem('token');
        router.replace(t ? '/dashboard' : '/login');
    }, [router]);
    return null;
}

================================================================================
FILE: patients/page.tsx  (size: 1995 bytes)
================================================================================
'use client';
import { useState } from 'react';
import { invitePatient } from '@features/auth/api';
import { useAuthGuard } from '@features/auth/hooks';

export default function PatientsPage() {
    useAuthGuard();
    const [email, setEmail] = useState('');
    const [result, setResult] = useState<any | null>(null);
    const [err, setErr] = useState<string | null>(null);
    const [loading, setLoading] = useState(false);

    const onInvite = async (e: React.FormEvent) => {
        e.preventDefault();
        setLoading(true); setErr(null); setResult(null);
        try {
            const { data } = await invitePatient(email);
            setResult(data);
        } catch (e:any) { setErr(e?.response?.data?.error || 'Invite failed'); }
        finally { setLoading(false); }
    };

    return (
        <main className="p-6 max-w-2xl mx-auto">
            <h1 className="text-2xl font-semibold mb-4">Invite Patient</h1>
            <form onSubmit={onInvite} className="bg-white rounded p-4 shadow">
                <label className="block text-sm mb-1">Patient Email</label>
                <input className="w-full border rounded px-3 py-2 mb-3" value={email} onChange={e=>setEmail(e.target.value)}/>
                <button disabled={loading} className="bg-black text-white rounded px-4 py-2">{loading?'Inviting...':'Send Invite'}</button>
            </form>
            {err && <div className="mt-4 bg-red-100 text-red-700 p-2 rounded">{err}</div>}
            {result && (
                <div className="mt-4 bg-green-50 p-3 rounded border">
                    <p className="text-sm">Invite created.</p>
                    <p className="text-sm break-all"><strong>Token:</strong> {result.token}</p>
                    <p className="text-sm break-all"><strong>Link:</strong> {result.link}</p>
                    <p className="text-sm"><strong>Expires:</strong> {new Date(result.expiresAt).toLocaleString()}</p>
                </div>
            )}
        </main>
    );
}

================================================================================
PROJECT TREE
================================================================================
app/
├── dashboard/
│   └── page.tsx
├── login/
│   └── page.tsx
├── patients/
│   └── page.tsx
├── code.txt
├── collect_text_and_tree.py
├── globals.css
├── layout.tsx
└── page.tsx

================================================================================
SUMMARY
================================================================================
Text files written : 7
Non-text/omitted   : 0
Total files seen   : 7
